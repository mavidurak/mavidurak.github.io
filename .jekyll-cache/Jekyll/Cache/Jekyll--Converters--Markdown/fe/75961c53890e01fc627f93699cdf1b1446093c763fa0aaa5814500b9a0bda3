I"†,<p>Merhabalar,
Vizelerin, finallerin vs. araya girmesiyle neredeyse iki aydÄ±r yazmaya vakit bulamamÄ±ÅŸtÄ±m.
BugÃ¼n elimden geldiÄŸince stack tabanlÄ± zafiyetlerden ve ne ÅŸekilde exploit edilebileceÄŸinden bahsetmeye Ã§alÄ±ÅŸacaÄŸÄ±m.Sonraki yazÄ±larda stack tabanlÄ± zafiyetlerin windows ve linux Ã¼zerinde exploit edilmesini anlatarak exploit geliÅŸtirme konularÄ±na girmeyi dÃ¼ÅŸÃ¼nÃ¼yorum.Bu yazÄ± daha Ã§ok stack overflow zafiyetinin mantÄ±ÄŸÄ±nÄ± anlamaya yÃ¶nelik olacaktÄ±r.
Her neyse fazla uzatmadan baÅŸlayalÄ±m.<!--more--></p>

<h2 id="buffer-overflow-arabellek-taÅŸmasÄ±-nedir">Buffer Overflow (Arabellek TaÅŸmasÄ±) Nedir?</h2>

<p>Buffer, hafÄ±zada ard arda dizili tÃ¼rde veri tipi(int,char gibi) depolayan hafÄ±za bloÄŸudur.Câ€™de bunlar array olarak geÃ§er.</p>

<p>Buffer Overflow ise, hatalÄ± bir ÅŸekilde kullanÄ±lan fonksiyonlardan oluÅŸan(strcpy,strcmp vs.) bir programda yer alan deÄŸiÅŸkenlere, saklama kapasitelerinden daha fazla veri yÃ¼klenmesi ile programÄ±n crash olmasÄ± durumuna denir.E tamam sonra ne olacak? Kapasite aÅŸÄ±ldÄ±ÄŸÄ±ndan dolayÄ± programÄ±n akÄ±ÅŸÄ±, normal akÄ±ÅŸta olmayan kodlarla yani shellcode olarak tabir edilen kodlar ile deÄŸiÅŸtirilebilir.</p>

<p>YukarÄ±daki tanÄ±mÄ± daha anlaÅŸÄ±lÄ±r bir ÅŸekilde aÃ§Ä±klarsak eÄŸer; buffer overflow, programda ayrÄ±lmÄ±ÅŸ olan tampon bellek bÃ¶lgesine kapasitesinden daha fazla veri yÃ¼klenerek ve bunun sonucunda belleÄŸin taÅŸmasÄ± ile ortaya Ã§Ä±kmÄ±ÅŸ bir zafiyettir.</p>

<h2 id="gÃ¼zel-diyorsun-da-stack-nedir">GÃ¼zel Diyorsun da â€œStackâ€ Nedir??</h2>
<p>RAMâ€™in dÃ¼ÅŸÃ¼k adresten baÅŸlayÄ±p yÃ¼ksek adrese giden bir yapÄ±sÄ± vardÄ±r.Ä°ÅŸletim sisteminde yeni bir thread oluÅŸturulduÄŸunda bellekte; fonksiyon parametrelerini, lokal deÄŸiÅŸkenleri ve fonksiyonlarÄ±n Ã§alÄ±ÅŸmasÄ± sonlandÄ±ktan sonra devam edeceÄŸi yeri saklamak iÃ§in, yÄ±ÄŸÄ±n(stack) denilen alanlar oluÅŸturulur. Her thread iÃ§in iki yÄ±ÄŸÄ±n oluÅŸturulur.Stack ya da diÄŸer ismiyle YÄ±ÄŸÄ±n, kÄ±saca anlatmak gerekirse programlardaki deÄŸiÅŸkenlerin geÃ§ici olarak hafÄ±zada bulunduÄŸu bÃ¶lgedir.Bu bÃ¶lgede dinamik deÄŸiÅŸkenler, fonksiyon Ã§aÄŸrÄ±larÄ±(jmp, call vs.), return deÄŸerleri gibi kÄ±sÄ±mlar saklanÄ±r.
Stack, LIFO(Last-In-First-Out) mantÄ±ÄŸÄ±yla yani son giren ilk Ã§Ä±kar mantÄ±ÄŸÄ±yla Ã§alÄ±ÅŸÄ±r.
PUSH iÅŸlemi ile stackâ€™e yeni bir eleman eklenirken, POP iÅŸlemi ile stackâ€™in en Ã¼stÃ¼ndeki eleman stackâ€™ten Ã§Ä±karÄ±lÄ±r.
Ä°ÅŸletim sistemi, her thread(process) iÃ§in yeni bir stack alanÄ± ayÄ±rÄ±r. Stack yeni oluÅŸturulduÄŸunda EBP ve ESP registerâ€™larÄ± aynÄ± yeri gÃ¶sterir. Stackâ€™e eleman PUSH edildikÃ§e EBP registerâ€™i sabit kalÄ±rken, ESP registerâ€™Ä±nÄ±n deÄŸeri gittikÃ§e azalÄ±r.</p>

<p>Stack yapÄ±sÄ±nÄ± ÅŸu ÅŸekilde Ã§izmeye Ã§alÄ±ÅŸtÄ±m:
<img src="http://ferdogan.net/assets/stack.png" alt="Stack YapÄ±sÄ±" /></p>

<h2 id="fonksiyonlarÄ±n-Ã§aÄŸÄ±rÄ±lmasÄ±-olayÄ±">FonksiyonlarÄ±n Ã‡aÄŸÄ±rÄ±lmasÄ± OlayÄ±##</h2>

<p>Fonksiyon Ã§aÄŸÄ±rÄ±lmadan Ã¶nce, fonksiyon iÃ§indeki parametrelerin saklandÄ±ÄŸÄ± EIP(Instruction Pointer) ve EBP(Base Pointer) registerlarÄ± stack Ã¼zerine kopyalanÄ±r.Fonksiyon iÅŸlemleri tamamlandÄ±ktan sonra saklanan EIP registerâ€™Ä± stackâ€™ten alÄ±narak EIP registerâ€™Ä±na kopyalanÄ±r ve program akÄ±ÅŸÄ± kaldÄ±ÄŸÄ± yerden devam eder.SanÄ±rÄ±m bunu Ã¶rnekle aÃ§Ä±klamaya Ã§alÄ±ÅŸsak daha iyi olacak.</p>

<p>Åimdi bir fonksiyonunuz olduÄŸunu ve program iÃ§inde onu Ã§aÄŸÄ±rdÄ±ÄŸÄ±nÄ±zÄ± dÃ¼ÅŸÃ¼nÃ¼n.Ã‡aÄŸÄ±rdÄ±nÄ±z fonksiyon Ã§alÄ±ÅŸtÄ± bir ÅŸeyler yaptÄ± sonra gÃ¶revi bitti ve program kaldÄ±ÄŸÄ± yerden Ã§alÄ±ÅŸmaya devam etti.Tamam ama bu iÅŸlemler nasÄ±l oldu? Ä°nceleyelim efendimâ€¦</p>

<p>Bu kÄ±smÄ± anlatmak iÃ§in arkadaÅŸÄ±m Bekir Karulâ€™un konuyla ilgili Ã¶rneÄŸinden yararlanmayÄ± uygun gÃ¶rdÃ¼m.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">sayi</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="n">biseylerYap</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">);</span>
<span class="n">sayi</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span></code></pre></figure>

<p>YukarÄ±daki kodlar ne yaptÄ±?
Ã–nce sayi deÄŸiÅŸkeninin deÄŸeri 5 oldu, sonra program biseylerYap fonksiyonunu Ã§aÄŸÄ±rdÄ±, fonksiyon gÃ¶revini yaptÄ± sonra bir alt satÄ±ra geÃ§ti ve sayi deÄŸiÅŸkenini deÄŸeri 10 oldu.Bunun olabilmesi iÃ§in o fonksiyonun Ã§aÄŸÄ±rÄ±ldÄ±ÄŸÄ±nda gerÃ§ekleÅŸen â€œFunction Prologueâ€ denilen bir olay var orada, ÅŸimdi onu inceleyelim.</p>

<p>Function Prologue Ã¶zetle 3 ana iÅŸlemden oluÅŸuyor:</p>

<ol>
  <li>ESPâ€™nin deÄŸeri, EBP olarak kopyalanÄ±p, stackâ€™e push edilir.</li>
  <li>Bir sonraki instructionâ€™Ä±n adresi stackâ€™e push edilir.</li>
  <li>ArdÄ±ndan fonksiyon call edilir.</li>
</ol>

<p>Function Prologue olayÄ±nÄ± anlamak iÃ§in aÅŸaÄŸÄ±daki kodu inceleyelim.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">gcc</span> <span class="n">ferdogan</span><span class="o">.</span><span class="n">c</span> <span class="o">-</span><span class="n">S</span> <span class="o">-</span><span class="n">o</span> <span class="n">ferdogan</span><span class="o">.</span><span class="n">S</span> </code></pre></figure>

<p>komutuyla kodu derleyin.</p>

<p><img src="http://ferdogan.net/assets/kod.png" alt="kod" /></p>

<p>ferdogan.S dosyasÄ±nÄ±n iÃ§inde programÄ±n assembly halini inceleyebilirsiniz.</p>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="n">pushl</span> <span class="err">%</span><span class="n">ebp</span>
<span class="n">movl</span>  <span class="err">%</span><span class="n">esp</span><span class="p">,</span> <span class="err">%</span><span class="n">ebp</span>
<span class="k">call</span>  <span class="n">_patlayici</span> </code></pre></figure>

<p>YukarÄ±daki iÅŸlemleri sÄ±rasÄ±yla aÃ§Ä±klamak gerekirse:</p>

<ol>
  <li>Base pointer deÄŸeri stackâ€™e gÃ¶nderiliyor.</li>
  <li>Yeni base pointer deÄŸeri, stack pointerâ€™Ä±n deÄŸeri ile deÄŸiÅŸtiriliyor.</li>
  <li>ArdÄ±ndan call komutu ile fonksiyon Ã§aÄŸÄ±rÄ±lÄ±yor.</li>
</ol>

<p>Bu anlattÄ±ÄŸÄ±mÄ±z fonksiyona girerken olan iÅŸlemler.Bir de bunun tersi var: â€œFunction Epilogueâ€
Tahmin ettiÄŸiniz Ã¼zere epilogue bu iÅŸlemlerin tam tersi.</p>

<p><img src="http://ferdogan.net/assets/prologue.png" alt="prologue" /></p>

<p>Evet masaÃ¼stÃ¼ arkaplan bÃ¼yÃ¼klÃ¼ÄŸÃ¼ndeki bir resimden sonra kaldÄ±ÄŸÄ±mÄ±z yerden devam edelim :)</p>

<blockquote>
  <ul>
    <li>Bir Programda fonksiyon Ã§aÄŸÄ±rÄ±lmadan Ã¶nce fonksiyon parametreleri yÄ±ÄŸÄ±na yazÄ±lÄ±r. ArdÄ±ndan fonksiyona girilmeden Ã¶nce dÃ¶nÃ¼ÅŸ adres deÄŸeri stackâ€™e atÄ±lÄ±r ve dÃ¶nÃ¼ÅŸ adres deÄŸeri fonksiyon sonlanÄ±rken tekrar Ã§aÄŸÄ±rÄ±larak program icrasÄ±na devam eder. Son olarak fonksiyondaki lokal deÄŸiÅŸkenleri tutmak iÃ§in bir buffer alanÄ± oluÅŸturulur. Klasik arabellek taÅŸmasÄ± bu alanÄ±n taÅŸÄ±rÄ±larak EIP(Ä°nstruction Pointer)â€™ye istenen bir deÄŸerin yazÄ±lmasÄ± ve bÃ¶ylece program akÄ±ÅŸÄ±nÄ±n deÄŸiÅŸtirilmesi durumudur.</li>
  </ul>
</blockquote>

<h2 id="tamam-peki-stack-overflow-nasÄ±l-oluÅŸuyor">Tamam peki â€œStack Overflowâ€ NasÄ±l OluÅŸuyor?</h2>

<p>Fazla detaya girmeden mantÄ±ÄŸÄ±nÄ± aÃ§Ä±klamaya Ã§alÄ±ÅŸÄ±rsam ÅŸu ÅŸekilde oluÅŸuyor:</p>

<p>Bir programda genellikle sabit uzunlukta tampon belirlenir, bu tampon bÃ¶lgesine gereÄŸinden fazla veri yazÄ±larak, yÄ±ÄŸÄ±n taÅŸmasÄ± oluÅŸur.Bu durum hataya yol aÃ§ar(crash durumu).Bu, genellikle yÄ±ÄŸÄ±n bitiÅŸik veri bozulmasÄ± ile sonuÃ§lanÄ±r(access violation) ve taÅŸma yanlÄ±ÅŸlÄ±kla tetiklenmiÅŸ ve programÄ±n Ã§Ã¶kmesine neden olur. 
Stackâ€™in aÅŸÄ±rÄ± doldurulmasÄ± stack Ã¶beÄŸi Ã¼zerinde programÄ±n yÃ¶nÃ¼nÃ¼n deÄŸiÅŸtirilmesine neden olur.</p>

<p>Biraz daha ayrÄ±ntÄ±lÄ± ele alalÄ±m:</p>

<p>Stack alanÄ± dolup taÅŸtÄ±ktan sonra, EIP registerâ€™Ä±nÄ±n deÄŸeri deÄŸiÅŸtirilerek programÄ±n akÄ±ÅŸ yÃ¶nÃ¼ deÄŸiÅŸtirilir.EIP yani instruction pointer, programda Ã§alÄ±ÅŸtÄ±rÄ±lacak bir sonraki kodun adresini tutar.Bu adresi degiÅŸtirirsek programÄ±n akÄ±ÅŸ yÃ¶nÃ¼nÃ¼ istedigimiz ÅŸekilde deÄŸiÅŸtirebiliriz.EBP(Base Pointer) stackâ€™in baÅŸlangÄ±cÄ±nÄ± gÃ¶sterir. ESP(Stack Pointer) ise yapÄ±lan push pop iÅŸlemlerine gÃ¶re deÄŸiÅŸir(stackâ€™in bÃ¼yÃ¼mesi-kÃ¼Ã§Ã¼lmesi).</p>

<h3 id="uygulama-zamanÄ±">Uygulama ZamanÄ±!</h3>

<p>AÅŸaÄŸÄ±da oldukÃ§a masum gÃ¶rÃ¼nen bir programÄ±mÄ±z var.</p>

<p><img src="http://ferdogan.net/assets/kod2.png" alt="overflow" /></p>

<p>ArgÃ¼man olarak bir deÄŸer alÄ±nÄ±yor, ardÄ±ndan bu deÄŸer fonksiyon iÃ§erisinde tanÄ±mlanan degisken isimli 120 baytlÄ±k alana kopyalaniyor.Peki 120 bayttan fazla veri girilince ne olacak?Ä°ÅŸte o zaman stack overflow denilen zafiyet oluÅŸuyor!</p>

<p><img src="http://ferdogan.net/assets/overflow.png" alt="overflow1" /></p>

<p>BelleÄŸe 120 bayttan daha fazla veri yazÄ±ldÄ±ÄŸÄ±nda bu veriler stack Ã¼zerine kopyalanmaya devam edecektir. Bu durumda programa girdi olarak Ã§alÄ±ÅŸtÄ±rÄ±lmasÄ±nÄ± istediÄŸimiz kodu belirtebilir ve EIPâ€™Ä± bu koda yÃ¶nlendirerek (JMP ESP) exploit edebiliriz.</p>

<p><img src="http://ferdogan.net/assets/overflow2.png" alt="overflow2" /></p>

<p>Stack tabanlÄ± buffer overflow mantÄ±ÄŸÄ± bu ÅŸekilde.UmarÄ±m anlaÅŸÄ±lmÄ±ÅŸtÄ±r.</p>

<h3 id="dikkat-patlayÄ±cÄ±">Dikkat PatlayÄ±cÄ±!</h3>
<p>Åimdi bu zararsÄ±z gÃ¶rÃ¼nen ufak uygulamayÄ± overflow edelim.</p>

<ul>
  <li>AÅŸaÄŸÄ±da programÄ±n disassembly edilmiÅŸ halini inceleyebilirsiniz.Function prologue olaylarÄ±nÄ± vs. gÃ¶rebilirsiniz:</li>
</ul>

<p><img src="http://ferdogan.net/assets/overflow3.png" alt="overflow3" /></p>

<ul>
  <li>
    <p><img src="http://ferdogan.net/assets/overflow4.png" alt="overflow4" /></p>
  </li>
  <li>
    <p>PatlayÄ±cÄ±â€™yÄ± ImmunityDebugger ile aÃ§tÄ±m.ArdÄ±ndan Debug &gt; Arguments menÃ¼sÃ¼nden programa argÃ¼man olarak 200 tane D harfi verdim.</p>
  </li>
</ul>

<p><img src="http://ferdogan.net/assets/D.png" alt="D" /></p>

<p><img src="http://ferdogan.net/assets/overflow5.png" alt="overflow5" /></p>

<ul>
  <li>ArdÄ±ndan programÄ± Ã§alÄ±ÅŸtÄ±rÄ±yorum ve sonuÃ§: BOM! 
 <img src="http://ferdogan.net/assets/overflow6.png" alt="overflow6" />
 ProgramÄ±mÄ±z Ã§Ã¶kÃ¼yor.</li>
</ul>

<p>RegisterlarÄ±n son halini ve alt tarafta stackâ€™in durumunu gÃ¶rÃ¼yorsunuz. EBP ve EIP registerlarÄ±nÄ±n deÄŸeri  44444444, bunun anlamÄ± hexdecimal olarak 44â€™Ã¼n ASCII tablosunda D harfini iÅŸaret etmesi.</p>

<p>SonuÃ§ olarak stack doldu taÅŸtÄ± ve programa girdiÄŸimiz argÃ¼man, programÄ±n akÄ±ÅŸÄ±nÄ± deÄŸiÅŸtirebilecek olan EIP registerÄ±nÄ±n deÄŸerini etkiledi.</p>

<blockquote>
  <ul>
    <li>Bu tarz bir durumdan kurtulmak iÃ§in strcpy fonksiyonunu kullanmak yerine strncpy fonksiyonunu kullanabilirsiniz.Bu tarz korunma yÃ¶ntemlerine ilerleyen yazÄ±larda deÄŸinmeyi dÃ¼ÅŸÃ¼ndÃ¼ÄŸÃ¼m iÃ§in ÅŸimdilik bahsetmiyorum.</li>
  </ul>
</blockquote>

<p>Uzun zaman sonra biraz uzun bir yazÄ± oldu, sÄ±kÄ±lmadan okuduÄŸunuz iÃ§in teÅŸekkÃ¼r ederim.YazÄ±nÄ±n baÅŸÄ±nda da bahsetmiÅŸtim.Bir sonraki yazÄ±larda konuyla ilgili windows ve linux Ã¼zerinden uygulama yapmayÄ± planladÄ±ÄŸÄ±m iÃ§in konuyu burada bitiriyorum.
Bir sonraki yazÄ±da gÃ¶rÃ¼ÅŸmek Ã¼zere.</p>

<p><a href="http://ferdogan.net/security/2015/01/07/Stack-Overflow-Zafiyetleri-Exploiting/">Kaynak</a></p>

:ET